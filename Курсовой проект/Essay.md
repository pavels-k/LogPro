# Реферат
## по курсу "Логическое программирование"

### студент: Шевчук П.В.

## ТЕМА Современные языки и системы логического программирования

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение: немного истории и общий принцип логического программирования

Первым языком логического программирования был Planner, который был реализован в системе polper и в других производных системах. Язык был разработан для действий с роботами. Первые публикации, связанные с этим языком появились в 1969 году. Был разработан Карлом Хьюиттом из MIT в 1971 году. Язык обладал некоторыми уникальными возможностями, например, для экономии пространства и времени принято предположение об уникальном имени, предполагая, что разные имена относятся к разным объектам. Предполагалось, что омонимы относятся к разным объектам. Также  можно строить и изменять описание среды (базы данных), в которых существуют наборы фактов и теорем. Если теоремы перестают быть истинными, то они должны быть удалены из среды. Был введён автоматический возврат (backtracking). От этого языка произошло много других логических языков программирования. 
В 1972 году появился логический язык программирования Prolog, создателем которого является Ален Колмероэ. Единицей Prolog являются термы, которые в свою очередь делятся на простые и структурные (предикаты и другие). Простые состоят из переменных, констант и атомов. Программа выполнения основывается на древовидных структурах и  на автоматическом переборе с возвратом. В 1980-ых в Японии в рамках национальной программы надеялись, что язык может помочь при создании компьютеров пятого поколения. В те года Prolog серьёзно соревновался с языком программирования LISP. Потомками Prolog являются Visual Prolog, Mercury, Oz, Erlang, Strand. 
Mercury – это функционально-логический язык программирования со строгой типизацией, появившийся в 1995 году в Мельбурнском университете. Система типов взята с функционального языка программирования Haskell. В отличие от языка Prolog имеет возможность при компиляции указать, хотите ли вы иметь возможность запускать отладчик в программе или нет. 
В данный момент развивается Visual Prolog(имеет проприетарную лицензию), ранее известный как PDC Prolog и Turbo Prolog. 
Visual Prolog является строго типизированным объектно-ориентированным расширением Prolog. Visual Prolog может создавать графические приложения Microsoft Windows, консольные приложения, библиотеки DLL. Логические языки традиционно интерпретируются, но Visual Prolog компилируется.

## Современные языки логического программирования и эксплуатация SWI-Prolog

Логическое программирование было изобретено в начале 1970-х годов. Оно имело очень смешанный успех. В академической области постоянно был целью исследований. В коммерческом плане у него было незначительное воздействие с небольшим количеством компаний, использующих его в ограниченных целях. Вероятно, это связано со случайностью и факторами, которые находятся вне контроля учёных. Я считаю, что в современном мире логическое программирование может помочь с задачами, связанными с искусственным интеллектом: модели представления знаний и методы вычислений — мягкие вычисления, генетические алгоритмы, нейросети, логические модели и другие подходы. Все эти методы основаны на символьных вычислениях и поэтому могут быть реализованы на основе языка Prolog. Но Prolog сложнее изучить, чем многие другие языки программирования. Частично это связано с присущими ему причинами: Prolog проще и мощнее многих других языков программирования, поэтому для этого  нужно больше времени, чтобы лучше ознакомиться с низкоуровневым языком. Однако в ограничениях существующего учебного материала обнаруживается гораздо более важная причина: во многих случаях Prolog преподается точно так же, как и в 1980-х и 1990-х годах. Устаревшие учебные материалы приводят к нарушенным обещаниям: использование низкоуровневых и языковых функций усложняют логические рассуждения о программах на Prolog, заставляя учащихся думать о своих программах функционально, а не по декларативному принципу. Самые последние и текущие события Prologа происходят в университетах и в учреждениях, которые тесно связаны с научными кругами. Важными областями современного исследования являются вероятностное логическое программирование, программирование набора ответов и языковые диалекты, которые удовлетворяют определенным критериям безопасности или другим интересным свойствам. В будущем наиболее влиятельными материалами о Prolog станут те, которые наиболее явно раскрывают чистое ядро Prolog и уникальные преимущества, возможности применения логического программирования и ограничений, таких как: декларативная отладка, декларативная целочисленная арифметика, комбинаторная оптимизация. 
Mercury - новый, чистый логико-функциональный язык программирования. Подобно другим существующим языкам логического программирования, это язык программирования на высоком уровне, который позволяет программистам сосредоточиться на решении проблемы, а не думать о низкоуровневых зависимостях, таких как управление памятью. Проект под названием Mercury был создан в 1995 году. В результате с декабря 2002 года появилась версия, которая поддерживает большинство системных платформ.
 Но мне бы хотелось остановиться на расширение Prolog SWI-prolog. Большинство современных 64-битных платформ способно работать как с 32-битными, так и с 64-битными приложениями. SWI-Prolog может быть скомпилирован для 32-ух или 64-разрядного адресного пространства в любой системе с подходящим компилятором языка C. 
Большая часть использования памяти Prolog состоит из указателей. Это указывает на основной недостаток: использование памяти Prolog почти удваивается при использовании 64-разрядной адресной модели. Использование большего количества памяти означает копирование большего количества данных между CPU и основной памятью, замедляя работу системы. В чем же преимущества? Прежде всего, адресация SWI-Prolog для стеков Prolog не охватывает всего адресного пространства из-за использования флагов сбора мусора. На 32-битном оборудовании стеки ограничены 128 МБ каждый. Это, как правило, слишком мало для требовательных приложений на современном оборудовании. На 64-битном оборудовании предел в 2^32 раза выше, превышая возможности адресации современных процессоров и операционных систем. Это означает, что Prolog можно запустить с размерами стека, которые используют все возможности вашего оборудования. 
Многопоточные приложения выигрывают гораздо больше, потому что каждый поток имеет свой собственный набор стеков. Стеки Prolog начинаются с малого и динамически расширяются. Стек C также динамически расширяется, но максимальный размер зарезервирован при запуске потока. Использование 100 потоков в максимальном стеке C по умолчанию для 8Mb (Linux) стоит 800 Мб виртуальной памяти. Последствия теоретических потерь производительности из-за увеличения пропускной способности памяти, подразумеваемых путем обмена более широкими указателями, зависят от дизайна аппаратного обеспечения. 
“Есть только данные для популярных архитектур IA32 и AMD64. Здесь представляется, что потери компенсируются набором команд, который был оптимизирован для современного программирования. В частности, AMD64 имеет больше регистров и улучшены возможности относительной адресации. Когда мы обнаруживаем снижение производительности на 10% при размещении ядра SWI-Prolog в общем объекте Unix, мы не можем найти измеримую разницу на AMD64.”
Прежде всего, если SWI-Prolog необходимо связать с 32-ух или 64-разрядными родными библиотеками, выбор невозможен, так как невозможно связать 32- и 64-разрядный код в один исполняемый файл. Только в том случае, если все необходимые библиотеки доступны в обоих размерах, и нет ясных оснований для использования.
В приложениях Prolog, для которых требуется ограничение на размер стека размером 128 МБ (но которое предусмотрено в режиме 32-разрядной адресации), необходимо использовать 64-разрядную версию. 
Если система жестко связана с физической памятью, 32-битный Prolog имеет явное преимущество в использовании чуть более половины памяти 64-битного Prolog. Этот аргумент применяется до тех пор, пока приложение вписывается в виртуальное адресное пространство машины. Виртуальное адресное пространство 32-разрядного оборудования составляет 4 ГБ, но во многих случаях операционная система обеспечивает меньше приложений пользователей.

## Заключение

Таким образом, можно сделать вывод, что в индустрии искусственного интеллекта мы обладаем множеством хороших логических языков программирования. Существуют такие системы как: базы данных, генетические алгоритмы, экспертные системы и т.д. С их помощью можно сделать нечто очень мощное и особое. Но хотелось бы отметить что, если бы было более ясно, как работают такие языки программирования, как Prolog, то многие программисты увлекались бы ими, так как теперь такие языки относятся к языкам более низкого уровня. Наша задача заключается в привлечении большего количества людей.  
Подводя итоги правильной эксплуатации SWI-Prolog, нужно сказать, что если приложения достаточно малы, чтобы удобно вместить виртуальную и физическую память, надо просто взять модель, используемую большинством приложений в операционных системах. Если для приложений требуется более 128 МБ на стек, надо использовать 64-разрядную версию. Если приложения подходят к размеру физической памяти, вписываются в ограничение стека 128 МБ и вписываются в виртуальную память, 32-разрядная версия имеет явные преимущества. Для требовательных приложений на 64-битном оборудовании с физической памятью объемом более 6 ГБ лучший выбор - это 64-битная модель.

## Источники информации

1. https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 – Логическое программирование

2.	 https://habrahabr.ru/post/277229/ - Профессиональное программирование для систем искусственного интеллекта на языке  prolog

3.	https://ru.wikipedia.org/wiki/Planner - Planner 

4.	http://mercurylanguage.ucoz.ru/ - Язык программирования Mercury

5.	http://www.swi-prolog.org/pldoc/man?section=64bits - SWI-Prolog and 64-bit machines
