#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Шевчук П.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Для решения задач с некоторым набором ситуаций, где из начального состояния нужно перейти в конечное с помощью каких-то действий, очень удобно использовать логический язык программирования Prolog. В нем не нужно указывать как получить нужное значение, в нем указывается что именно пользователь хочет получить. Если в задаче не так много состояний, то разница между этими двумя подходами будет несущественная. Однако для задач с большим количеством состояний очень трудно прописать каждый путь, и Prolog подходит лучше всего для решения подобных задач. 

## Задание

Вдоль доски расположено 8 лунок, в которых лежат 4 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непостредственно за ближайшим шаром.

## Принцип решения

Написал предикат step, в котором описал правила сдвига шаров в лунках. step создает два списка, с начальным и конечным состояниями. 
```prolog 
step(A,B):- 
  my_append(H,["_","w"|Tail],A), 
  my_append(H,["w","_"|Tail],B). 
step(A,B):- 
  my_append(H,["b","_"|Tail],A), 
  my_append(H,["_","b"|Tail],B). 
step(A,B):- 
  my_append(H,["_","b","w"|Tail],A), 
  my_append(H,["w","b","_"|Tail],B). 
step(A,B):- 
  my_append(H,["b","w","_"|Tail],A), 
  my_append(H,["_","w","b"|Tail],B). 
 ``` 
 Далее реализовал предикат поиска в глубину. 
 ```prolog 
 depth(To,Tail):-!,answer(Tail). 
depth(To,[From|Tail]):-step(From,Tmp),not(member(Tmp,Tail)),depth(To,[Tmp,From|Tail]). 
``` 
Работет предикат следующим образом: сначала делается шаг, после проверяем, не оказались ли мы в состоянии, в котором уже были, рекурсивно запускаем функцию. 
 
Потом реализован итерационный способ. 
```prolog 
iter(Tail,To,Tail,0). 
iter(TempWay,To,Way,N):- 
 N > 0, 
 extend(TempWay,NewWay), 
 N1 is N-1, 
 iter(NewWay,To,Way,N1). 
 ``` 
 Делаем шаг и проверяем, не оказались ли мы в том состоянии, в котором были. За это отвечает предикат extend. Далее уменьшаем N(глубину) на 1 и рекурсивно заускаем функцию. 
 
И после реализовал поиск в глубину. 
```prolog 
breadth([From|_],To,From) :- From = _. 
 
breadth([[Last|HasBeen]|Other],To,Way):- 
   findall([Z,Last|HasBeen], 
   next(Last, HasBeen, Z), List), 
   my_append(List,Other,NewWays), 
   breadth(NewWays,To,Way). 
``` 
Написал предикат solve, который ищет решения всеми тремя способами. 
```prolog 
solve(From, To):- 
 write('Iterative'), nl, 
 get_time(S1), 
 for(Lvl, 1, 20), 
 iter([From], To, Way, Lvl), 
 answer(Way), 
 get_time(F1), 
 T is F1 - S1, 
 write('TIME IS '), write(T), nl, nl, 
  
 write('DEPTH'), nl, 
 get_time(S2), 
 depth(To, [From]), 
 get_time(F2), 
 T1 is F2 - S2, 
 write('TIME IS '), write(T1), nl, nl, 
 
 write('BREADTH'), nl, 
 get_time(S3), 
 breadth([[From]],To,Way), 
 answer(Way), 
 get_time(F3), 
 T2 is F3 - S3, 
 write('TIME IS '), write(T2), nl, nl, 
 !. 
``` 
## Результаты

```prolog 
?- solve(["b","b","b","b","_","w","w","w"],["w","w","w","_","b","b","b","b"]).
Iterative
[b,b,b,b,_,w,w,w]
[b,b,b,b,w,_,w,w]
TIME IS 7.486343383789062e-5

DEPTH
[b,b,b,b,_,w,w,w]
TIME IS 1.52587890625e-5

BREADTH
[b,b,b,b,_,w,w,w]
[b,b,b,b,w,_,w,w]
TIME IS 0.00012922286987304688

true.
``` 

## Выводы

В данной лабораторной работе мною были применены навыки работы с языком Prolog для решения задачи поиска в пространстве состояний. Prolog, в данном случае, оказался весьма удобным для решения данной задачи. Я написал три алгоритма поиска: в глубину, в ширину и с итеративным погружением. Все три алгоритма справились со своей задачей. Итеративный метод является модификацией поиска в ширину и глубину, но он будет полезен только для решения небольших задач, с малым количеством состояний. В отличие от алгоритма поиска в глубину или поиска в ширину, он будет искать кратчайший путь и если путь нашелся, то он закончит работу и не будет дальше перебирать варианты.




